# baekjoon //c++
---
## class1
- 1008번-소수점 개수 정하기(오차허용범위)
- 1152번-앞뒤 공백을 배제하기 위해 1번~마지막-1 / 공백 개수 이용
- 2439번-이중반복문 사용시 내부 반복문 변수 잘 사용(행,열)
- 2562번-배열 입력받고 출력하는법
- ' " \ 등등 입력시 앞에 \ 추가로 붙이기
- 10951번 런타임 에러 입력이 없을때까지 출력되게끔 해야됨
- 2577번 출력 이중반복문 변수 주의 / 간단한 코드 : 10으로 나눈 나머지로 뒤 숫자부터 숫자 세짐
- 3052번 일단 *다시 풀어보기 배열 개수를 나머지 중복에 이용하기
- 11720번 char, 아스키코드 활용 *다시풀어보기
- 10809번 알파벳 숫자개수만큼 배열을 -1로 초기화해놓고 시작
- 8958번 알고리즘 파악...은 했지만 초기화의 문제
- 아스키코드는 + 0 을 하면 출력된다~
---
## class2
- 30802번 sizeof는 int형의 경우 int가 4바이트임으로 4 * 배열 길이가 나온다
- 1978번 *다시풀어보기 알고리즘 잘 생각해보기 (자기숫자까지만 나누기)
- 2798번 *다시풀어보기 3중반복문, 겹치는 경우 빼기
- 2231번 *다시풀어보기 tmp % 10하고 tmp /= 10하면 백의자릿수는 십의 자릿수로 십의 자릿수는 일의 자릿수로 점점 땡겨와서 자릿수들끼리 더하기 가능!
- 2292번 그저 수학 머리가 안되는 내탓임을;;
- 15829번 길이가 너무 길어 소수인 1234567891로 나눠서 나머지로 해야함
- 2609번 예지의 방법이 미쳤다 *다시해보기 최대공약수, 최소공배수 구하는 공식을 잘 생각해보길
- 2775번 *다시풀어보기 2차원배열 이용, 범위가 적은 걸 이용해서 값 다 넣기 
- 2869번 O(1)만에 해야해서 반복문 못씀 딱 맞을때와 넘어갈때 구분해서 식 세우기
- 10989번 * 다시 풀어보기 sort 함수 쓰면 메모리 부족 / 값을 입력받았을때만 그 수의 배열 위치를 +시키고 arr[i]까지 i를 출력 arr[i] == 0이면 입력이 없다는 얘기이므로 i = 0이어서 i =1부터 시작이라 애초에 반복문을 거치지 않음 //..어려워
- 11050번 이항계수 식 사용하면 쉬움~
- 28702번 문제는 쉬움 stoi atoi compare 함수 사용법 처음 알았음
- 1181번 *다시 풀어보기 sort(1, 2, 3) 3부분 활용 잘하기 함수를 이용해서!!!! sort 활용문제 느낌
- 1436번 *다시 풀어보기 알고리즘은 내가 알아내지 못했다.. 666 들어가는 수가 작은수대로 증가한다는걸 이용
- 1676번 내가 쓴 코드는 팩토리얼 값이 너무 김 5 * 2는 무조건 끝에 0을 만들어내므로 5가 존재하면 그 밑에 2는 무조건 존재하니 5의 개수를 세주면 됨
- 2751번 sort함수를 쓰면 되는 간단한 문제~ 내림차순으로 잘못 봤다~
- 7568번 pair함수 이용 알고리즘 파악이 어려웠음 맞는 경우를 찾지 말고 아닌 경우를 제외하면서 가자
-10814번 원래는 stable_sort를 쓰면 간단함 sort 사용시 구조체 이용해서 입력순서 index로 받아주기!
-11650, 11651은 10814랑 같은 류의 문제
-1920번 O(N)은 시간초과, 이분탐색을 이용해야함 O(logN) binary_search함수는 sort한뒤 사용해야 하고 처음부터 끝까지 정해진숫자가 있는지 찾아주는 함수이다 중간값을 정한뒤 크기를 비교해가며 함으로 시간복잡도가 낮은 것이다
-2164번 1인 경우 고려안한거 빼고선 한번에 품 난 바로 선형큐 썼지만 원형큐 쓸시 시간초과 나는듯
-2839번 n이 5로 딱 나눠지지 않을때 3을 빼가면서 나머지가 0이 될때까지 반복
-4949번 기호 개수를 세서 같은지 비교해서 했지만 스택이 더 편리함
-9012번 위 문제랑 비슷한데 기호가 하나라 생각보다 간단하게 생각해야 함 비슷한 원리를 사용하긴 함
-10816번 sort함수로 정렬한뒤 upperbound 와 lowerbound를 사용해서 할수있다 upperbound는 찾는 수의 다음 숫자가 처음 나올때 lowerbound는 찾는 숫자가 처음나올때 그래서 upper - lower하면 그 숫자의 개수
-10845번 다 잘 풀어놓고선 어이없는 실수;;
-18110번 잘 품;; round함수는 반올림함수
-1929번 원래 소수 구하던 방식으로 하면 런타임 에러 에라토스테네스의 체 방법을 사용해야 함 2의 배수 3의 배수 4의 배수 등등 먼저 제거해놓는 방식
## class3